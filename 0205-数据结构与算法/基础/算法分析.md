判断算法的好坏
一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑算法的效率，通过算法的效率高低来评判不同算法的优劣程度。
算法效率
时间效率：指的是算法所耗费的时间。

空间效率：指的是算法执行过程中所耗费的存储空间。

时间效率和空间效率有时候是矛盾的。
时间效率的度量
算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量。

事后统计

将算法实现，测算其时间和空间开销。

缺点：编写程序实现算法将花费较多的时间和精力；所得实验结果依赖于计算机的软硬件等环境因素掩盖算法本身的优劣。

事前分析

对算法所消耗资源的一种估算方法
时间效率的事前分析方法
一个算法的运行时间，大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的时间与算法中进行的简单操作次数乘积。

算法运行时间 = 一个简单操作所需的时间 × 简单操作次数

也即算法中每条语句的执行时间之和。

算法运行时间 = Σ 每条语句的执行次数 × 该语句执行一次所需的时间

算法运行时间 = Σ 每条语句频度 × 该语句执行一次所需的时间

由于语句执行的时间取决于环境，和算法本身无关。因此可以假设每条语句所需的时间均为单位时间。

算法中基本语句重复执行的次数是问题规模n的某个函数f(n)算法的时间量度，记作：T(n)=O(f(n))。它表示，随着n的增大，算法执行的时间的增长率和f(n)的增长率相同，称渐进时间复杂度，简称时间复杂度。
时间复杂度的定理
- ![image1](../../../_resources/963c85574a0a49c79a11e18362c4ffb0.png)
- 忽略所有低次幂和最高次幂系数，体现增长率的含义。
时间复杂度的计算方法
1.  找出语句频度最大的那条语句作为基本语句。
2.  计算基本语句的频度得到问题规模 n 的某个函数 f(n)。
3.  取其数量级用符号“O”表示。
4.  一般总是考虑在最坏情况，下的时间复杂度以保证算法的运行时间不会比它更长。
5.  对于时间复杂的算法，可以将它分成n个容易估算的部分，然后利用大O加法法则和乘法法则计算算法的时间复杂度。
    1.  加法规则
![image2](../../../_resources/1d40270cb61b4f51a26d08dbd3c9d787.png)
2.  乘法规则
![image3](../../../_resources/513cb61f78e446299971413b742d31d7.png)
时间复杂度的比较
当n取的很大时，指数时间算法和多项式时间算法，在所需时间上非常悬殊。
| n   | f(1) | f(logn) | f(n) | f(nlogn) | !image4](../../../_resources/3b854f82d58e49608ded2ce64118c448.png)%20| !image5](../../../_resources/224d6cc9a9994f0e9a0344650b977273.png)|%20!image6](../../../_resources/4ae0ccdb5447425cbdf1d6c8fff2f592.png)%20| f(n!)|
|-----|------|---------|------|----------|-----------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------|------------|
| 1   | 1    | 0       | 1    | 0        | 1                                                                                                                                 | 1                                                                                                                                 | 2                                                                                                                                | 1          |
| 2   | 1    | 1       | 2    | 2        | 4                                                                                                                                 | 8                                                                                                                                 | 4                                                                                                                                | 2          |
| 4   | 1    | 2       | 4    | 8        | 16                                                                                                                                | 64                                                                                                                                | 16                                                                                                                               | 24         |
| 8   | 1    | 3       | 8    | 24       | 64                                                                                                                                | 512                                                                                                                               | 256                                                                                                                              | 40320      |
| 16  | 1    | 4       | 16   | 64       | 256                                                                                                                               | 4096                                                                                                                              | 65536                                                                                                                            | 2.0923E+13 |
| 32  | 1    | 5       | 32   | 160      | 1024                                                                                                                              | 32768                                                                                                                             | 4.295E+09                                                                                                                        | 2.6313E+35 |
时间复杂度按数量级的排序为

![image7](../../../_resources/62b3dbdd7e0c4489adb11947b24672c1.png)

存储据空间的度量
记作

S(n)=O(f(n))

其中n为问题的规模或大小
算法占据的空间
- 算法本身要占据的空间，例如输入/输出、指令、常数、变量等。
- 算法要使用的辅助空间

渐近时间复杂度具体计算过程
例如
计算两个n×n矩阵相乘
代码
for(int i=1;i\<=n;i++)
for(int j = 1;j\<=n;j++)
for(int k = 0;k \<n; k++)
c\[i\]\[j\]=c\[i\]\[j\]+a\[i\]\[k\]\*b\[k\]\[j\];

首先
把算法所消耗的时间，定义为该算法中每一条语句的频度之和。

则上述算法的时间消耗

![image8](../../../_resources/cacb00703a4c431da8ee534ae570de15.png)
然后
便于比较不同算法的时间效率，我们仅比较它们的数量级。

例如

两个不同的算法时间的消耗分别是：

![image9](../../../_resources/649dba94ff91483ca8ed4996d163fa7f.png)

![image10](../../../_resources/2de7c84032eb422289d2202d29929b71.png)
最后
![image11](../../../_resources/493304e657364b6dbec6dbc9d784d6e3.png)

![image12](../../../_resources/451b8c3fe2c84eca9fe2d62d34114a83.png)

![image13](../../../_resources/b22b848a4d994bc797a90dd555eba3ae.png)

对于时间复杂度随输入数据集的不同而不同的情况
例如
顺序查找在数组a\[i\]中，查找值等于e的元素，返回其所在位置。
代码
for(int i = 0; i \< n; i++)
if(a\[i\]==e) return i+1;
return 0;
时间复杂度T(n)
最好：1次
最坏：n次
平均时间复杂度：O(n)

空间复杂度的具体计算方式
举例
将一维数组a中的n个数逆序存放到原数组中。
代码1
for(int i = 0; i \< n/2; i++){
t=a\[i\];
a\[i\]=a\[n-i-1\];
a\[n-i-1\]=t;
}
代码2
for(int i = 0; i \< n; i++)
b\[i\]=a\[n-i-1\];
for(int i = 0; i \< n; i++)
a\[i\]=b\[i\];
空间复杂度
代码1：S(n)=O(1)

代码2：S(n)=O(n)

