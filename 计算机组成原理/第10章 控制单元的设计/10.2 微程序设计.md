# 微程序设计思想的产生

- 1951 英国剑桥大学教授 Wilkes
- 完成一条机器指令，需要n条微操作命令，几个微操作可以组合成一条由高低电平组成的微指令，每个高电平对应一个微操作
- 一条机器指令对应一个微程序，一个微程序包含多个微指令，一个微指令包含多个微操作
- 将这些高低电平保存在只读存储器ROM（存储逻辑）

![[images/Pasted image 20240307162934.png]]

# 微程序控制单元框图及工作原理

## 机器指令对应的微程序
![[images/Pasted image 20240307164039.png]]

## 微程序控制单元的基本框图

- CMAR：控制存储器*地址*寄存器
- CMDR：控制存储器*数据*寄存器
- 微地址形成部件：指令操作码转换成微地址
![[images/Pasted image 20240307164316.png]]

微指令基本格式
![[images/Pasted image 20240307164346.png]]

# 微程序控制单元框图及工作原理

如果微程序没有给出下地址，则从微指令形成部件内形成指令

- 间址周期微程序结束后，由微指令形成部件形成下一条微指令
- 中断周期微程序结束后，转到取指令周期微程序

## 工作原理

假如内存中保存的指令

```asm
LDA X
ADD Y
STA Z
STP
```

全部微指令存在CM中，程序执行过程中只需读出

### `LDA`取指阶段

- $M \to CMAR$
- $CM[(CMAR)]\to CMDR$
- 由$CMDR$发命令
  - $PC\to MAR$
  - $1\to R$
- 形成下条微指令地址 $M+1$
![[images/Pasted image 20240307165929.png]]

- $CMDR[AD]\to CMAR$
- $CM[CMAR]\to CMDR$
- 由$CMDR$发命令
  - $M[(MAR)]\to MDR$
  - $(PC)+1\to PC$
- 形成下条微指令地址 $M+2$
![[images/Pasted image 20240307170342.png]]

- $CMDR[AD]\to CMAR$
- $CM[CMAR]\to CMDR$
- 由$CMDR$发命令
  - MDR\to IR
![[images/Pasted image 20240307170332.png]]

### `LDA`执行阶段

- $IR[OP]\to 微地址形成部件 \to CMAR$
- $CM[CMAR]\to CMDR$
- 由$CMDR$发命令
  - $IR[AD]\to MAR$
  - $1\to R$
- 形成下条微指令地址 $P+1$
![[images/Pasted image 20240307182540.png]]

- $CMDR[AD]\to CMAR$
- $CM[CMAR]\to CMDR$
- 由$CMDR$发命令
  - $M[MAR]\to MDR$
- 形成下条微指令地址 $P+2$
![[images/Pasted image 20240307182754.png]]

- $CMDR[AD]\to CMAR$
- $CM[OP]\to CMDR$
- 由$CMDR$发命令
  - $MDR\to ACC$
- 形成下一条微指令$M$
![[images/Pasted image 20240307182837.png]]

### `ADD`取指阶段

- $CM[(CMAR)]\to CMDR$
- 由$CMDR$发命令
...
![[images/Pasted image 20240307200819.png]]

# 微指令的编码方式（控制方式）
## 直接译码（直接控制方式）
在微指令的控制操作控制字段中，每一位代表一个微操作命令

![[images/Pasted image 20240308074909.png]]

