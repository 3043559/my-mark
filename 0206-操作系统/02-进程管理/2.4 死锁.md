# 死锁

## 死锁的概念

**死锁**：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。


### 死锁、饥饿、死循环

- **死锁**：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象
	- 至少有两个或两个以上的进程同时发生死锁
	- 是管理者（操作系统）的问题
- **饥饿**：由于长期得不到想要的资源，某进程无法向前推进的现象
	- 可能只有一个进程发生饥饿
	- 是管理者（操作系统）的问题
- **死循环**：某进程执行过程中一直跳不出某个循环的现象
	- 可能只有一个进程发生死循环
	- 死循环是被管理者的问题
	- 死循环的进程可以上处理机运行

### 死锁产生的条件

- **互斥条件**：只有对必须互斥使用的资源的争抢才会导致死锁
	- 不用阻塞等待的资源不会导致死锁
- **不剥夺条件**：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
- **请求和保持条件**：进程*已经保持了至少一个资源*，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放
- **循环等待条件**：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。


>[!attention]+  注意：循环等待是死锁的必要不充分条件
>- 发生死锁时一定有循环等待
>- 但是发生循环等待时未必死锁

### 发生死锁的原因

- **对系统资源的竞争**：各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的
- **进程推进顺序非法**：请求和释放资源的顺序不当，也同样会导致死锁
	- 如并发执行的进程P1、P2分别申请，并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁
- **信号量的使用不当也会造成死锁**：如生产者—消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁

>[!tip]+  提示：可以把互斥信号量、同步信号量也看做是一种抽象的系统资源

### 死锁的处理策略

- **预防死锁**：破坏死锁产生的四个必要条件中的一个或几个
- **避免死锁**：用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)
- **死锁的检测和解除**：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁

## 死锁预防

- 不允许死锁发生
	- 静态策略：预防死锁，破坏[[#死锁产生的条件]]
	- 动态策略：避免死锁
- 允许死锁发生：死锁的检测和解除

### 破坏互斥条件

**破坏互斥条件**：把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态
- SPOOLing技术
- **该策略的缺点**：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件

### 破坏不剥夺条件

**破坏不剥夺条件**
- 方案一：当进程请求新的资源得不到满足时，必须立即释放保持的所有资源，待以后需要时再重新申请
	- 即使某些资源尚未使用完，也需要主动释放
- 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺
	- 这种方式一般需要考虑各进程的优先级
	- 剥夺调度方式：就是将处理机资源强行剥夺给优先级更高的进程使用
- 该策略的缺点
	- *实现起来比较复杂*
	- *释放资源会造成前阶段工作失效*：一般只适用于易保存和恢复状态的资源，如CPU


### 破坏请求和保持条件

**可以采用静态分配方法**：在运行前一次申请完所需要的全部资源，在资源未满足前，不让它投入运行。运行后，进程不会再请求别的资源
- 资源利用率极低：有些资源可能只需要用很短的时间，进程会在整个运行期间都一直保持着所有资源
- 可能导致进程饥饿

### 破坏循环等待条件

**可采用顺序资源分配法**：首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完
- *原理分析*：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。已持有大编号资源的进程不能逆向地申请小编号的资源，从而就不会产生循环等待的现象
- 该策略的缺点：
	- *不方便增加新的设备*：可能需要重新分配所有的编号
	- *会导致资源浪费*：进程实际使用资源的顺序可能和编号递增顺序不一致
- 